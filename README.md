# 💻 HTTP-WebServer

# 🎯 프로젝트 소개

`시스템 프로그래밍` 교과목 학기 Term 프로젝트입니다.

이번 학기에는 기존의 `Apache` 웹 서버와 유사한 원리로 동작하는 

`HTTP 웹 서버` 를 `Linux` 환경에서 구현하는 프로젝트를 진행했습니다.

기본적인 로그 파일 처리, ip 접근 권한 검사, 그리고 다중 클라이언트 대응이 가능한 서버입니다.

클라이언트에서 서버에게 HTTP 요청을 보내면 서버는 현재 수행되고 있는 환경의 디렉토리 구조 및 파일 시스템을 

`HTML 문서` 로 만들어서 클라이언트에게 제공 해줍니다.

이후 클라이언트(브라우저)는 해당 HTML 문서를 통해 파일을 다운로드 받거나 열람 해볼 수 있습니다.

# 📚 개발 환경

Linux Ubuntu 16.04 환경에서 C 언어 기반으로 개발

컴파일은 별도의 `Makefile` 을 활용함

디버깅은 `GDB` 를 활용해서 진행

# 🔥 주요 스펙

## 🗂 ls 모듈 기반 파일 탐색

우리의 웹 서버 프로그램은 리눅스에서 지원하는 `ls` 명령어와 같이 디렉토리 구조를 탐색한 뒤

해당 구조를 `HTML5` 문서로 생성해서 클라이언트에게 응답 메시지로 전송합니다.

동일한 로직을 수행하기 위해 Linux의 여러 시스템 콜과 옵션 파싱을 이용해서 `ls` 모듈을 구현했고

해당 모듈을 서버 프로그램에서 호출해서 디렉토리 구조를 알아오는 흐름으로 구조를 설계하였습니다.

### ls 모듈 지원 범위

해당 모듈은 실제 리눅스에서 제공하는 `ls 명령어` 와 동일한 인터페이스로 사용할 수 있도록 개발했습니다.

`ls` 명령어의 여러 옵션(`a, l, h, S, r`)들을 함께 사용할 수 있으며 와일드 카드(`*, ?`) 도 지원합니다.

초기에는 CLI 기준으로 개발을 했기 때문에 `argv` 값으로 옵션 값을 읽어 실행 결과를 콘솔에 출력했습니다.

이후 별도로 구현한 이 모듈을 구현한 `HTTP web server` 와 연동시켰습니다.

## 🔌 Linux Socket 시스템 콜 기반 Web server

![KakaoTalk_Photo_2021-01-14-23-34-34](https://user-images.githubusercontent.com/37819666/104606757-6ea74700-56c3-11eb-9b90-b8f914de5883.png)

해당 웹 서버는 HTTP 프로토콜을 준수하며 Linux OS 에서 제공하는 기본 시스템 콜을 활용해서 구현했습니다.

대표적으로 `socket, bind, listen, accept, connect` 가 있습니다.

## 🔐 다중 접속 및 접근 제어

### 다중 프로세스 접근

해당 HTTP 서버 프로그램은 `다중 접속 및 접근 제어` 기능을 제공합니다.

클라이언트의 접속 연결 및 해제 시 마다 로그 정보(클라이언트 IP, 포트 번호)를 기록하며 

동시에 다수의 클라이언트도 접근 가능합니다.

### Signal Processing

서버는 클라이언트에서 `connect` 요청이 들어 올 때마다 `accept` 를 통해 클라이언트의 연결 요청을 수락하고

이후의 작업을 `fork` 를 통해 생성된 자식 프로세스가 처리하도록 합니다.

이때 클라이언트에게 응답 메시지를 전송하고 자식 프로세스가 종료될 경우에 대한 처리가 필요합니다.

자식 프로세스가 종료되면 부모 프로세스에게 `SIGCHLD` 신호를 보내기 때문에 

이 신호에 신호 처리부를 등록해서 자식 프로세스의 종지 상태를 회수하고 `좀비 프로세스` 가 되는 것을 방지합니다.

마찬가지로 터미널에서 인터럽트를 발생시켜 부모 프로세스에게 `SIGINT` 가 전달되는 경우

부모를 종료하기전에 모든 자식 프로세스들을 먼저 종료시켜 자식들이 `고아 프로세스` 가 되는 것을 방지합니다.

추가적으로 서버 프로그램에서 주기적으로 로그를 기록하기 위해 `SIGALRM` 신호 처리부에 로그를 생성하는 로직을 등록합니다.

### 유저 whitelist 유지

유저 접근 권한 정보는 `accessible.usr` 파일에서 관리합니다.

이를 통해 미리 허용한 IP 를 가진 사용자만 해당 서버에 접속할 수 있습니다.

이때 IP 주소는 와일드카드(`*`)를 지원합니다.

만약 허가되지 않은 사용자가 접속할 경우 `403 forbidden` 을 반환합니다.

## ⚙️ process pool 생성 및 관리

### pre-forked server

![KakaoTalk_Photo_2021-01-14-23-34-42](https://user-images.githubusercontent.com/37819666/104606751-6cdd8380-56c3-11eb-9787-96cd74615d0d.png)

우리의 웹 서버는 `pre-forked` 방식으로 동작합니다.

클라이언트의 요청이 들어오기 전에 미리 `StartProcesss` 개의 자식 프로세스를 생성합니다.

이후 클라이언트의 요청이 생성되어 있는 자식 프로세스의 개수보다 많아 진다면 

최대 `Maxchilds` 만큼 생성해서 요청에 응답합니다.

이 설정 값은 `httpd.conf` 에서 변경할 수 있습니다.

### Idle process 관리

`idle process` 는 클라이언트와 연결이 되지 않은 자식 프로세스를 의미합니다.

해당 프로세스의 수를 `공유 메모리` 에서 관리하며 부모 프로세스에서 `idle process` 의 수가 변경 되는 것을 

감지하고 변화가 생길 경우 로그 파일에 기록합니다.

만약 `MinIdleNum > idle process` 혹은 `idle process > MaxIdleNum` 이 된다면 

현재 자식 프로세스를 생성 또는 종료하여 5개를 유지하도록 합니다.

**공유 메모리 임계 구역 문제**

다수의 프로세스가 공유 메모리(공유 자원)에 접근하는 임계 구역 문제 해결을 위해서 `mutex` 를 활용했습니다.

자식 프로세스에서는 `mutex` 를 통해 공유 메모리에 접근하고 이후 `idle process count` 정보를 갱신합니다.

Linux 에서는 `pthread_mutex_lock` 과 `pthread_mutex_unlock` 으로 구현 가능합니다.

### 로그 관리 및 process 동기화

로그 파일(`server_log.txt`) 을 생성하고 하기 위한 과정은 

자식 프로세스에서 별도의 `스레드` 를 생성한 뒤 이를 통해 이루어집니다.

클라이언트의 요청 정보, 자식 프로세스의 `idle` 상황 등 여러 정보가 로그 파일에 기록됩니다.

**로그 파일 임계 구역 문제**

마찬가지로 공유 자원인 로그 파일의 동기화를 위해 이번에는 `semaphore` 를 사용하여 구현했습니다.

`semaphore` 를 사용했지만 `mutex` 와 동일하게 한 번에 하나의 스레드만 접근 가능하도록 보장합니다.

# 🕹 동작 테스트

프로그램 구현은 `VM` 을 이용하여 로컬 환경에서 진행했습니다.

실제 서버 프로그램으로서 동작 확인을 위해 해당 학기 연구실 운영 서버를 할당 받아서 테스트를 수행했습니다.

원격 접속은 `XShell` 을 사용했고 클라이언트는 `Firefox` 브라우저를 활용했습니다.

# 🎥 데모
